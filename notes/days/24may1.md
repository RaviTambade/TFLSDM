

Hi, good morning everyone.

Welcome to this week‚Äôs session. I can see that most of you are now getting comfortable with the rhythm of software engineering. Remember, it‚Äôs not just about theory‚Äîit is a practice, a way of thinking, and most importantly, a way of doing.

To make this practice real, we are walking through a case study together: building an e-commerce application. Think of it as our online shopping service, something that touches real people‚Äôs lives. If we were to develop such an application, we cannot just jump into coding. We must follow the discipline of the software engineering process.

We have already discussed requirement gathering, where we try to understand the business, the operations, and the customer expectations. Then we moved into planning‚Äîdefining what needs to be done, by whom, and how. From there, we reached one of the most important outputs of this stage: the **System Requirement Specification (SRS)**.

The SRS is like the first script of our story. It defines the purpose‚Äîwhy we are doing this project, the scope‚Äîwhat we will include and what we will not, and the objectives‚Äîwhat exactly success will look like for us and for our customer. And inside it, lies the most critical section: the **functional requirements**.

Some of you have already tried drafting such documents. At first, writing them feels challenging. But once you gain experience in the IT industry, you‚Äôll realize that good documentation is as important as writing clean code. Without it, the story of your software is incomplete.

So let‚Äôs think again about functional requirements. What are they? They describe what the system should actually do. They define the functional modules‚Äîthe working building blocks of the application. In our online shopping system, those modules include:

* Customer registration
* Login
* Product catalog
* Shopping cart
* Payment
* Delivery
* Billing
* Feedback

These are not just buzzwords. They are the beating heart of the application. Without registration, customers cannot buy. Without login, customers cannot access their cart. Without a catalog, they cannot even see what products exist. Each requirement, when written clearly, becomes like a rulebook of do‚Äôs and don‚Äôts for your system.

For example, registration: if a customer wants to buy a product, he or she must register. Login: only registered users can enter the system with a valid username and password. Browse products: customers can view the catalog and select what they like. Feedback: customers can share their experience, helping us improve and keep them happy.

Notice how I keep using the word **customer** instead of ‚Äúend user.‚Äù That‚Äôs deliberate. In this business context, the one who browses, adds to cart, pays, and expects delivery is the customer. Using the right words makes our requirements closer to reality and easier to understand for both business people and developers.

Now, here‚Äôs how we will move ahead today. We‚Äôll complete our functional requirements for the online shopping case. Then, we‚Äôll shift gears to **object-oriented analysis and design**, where we start visualizing these requirements as classes, objects, and relationships. Finally, we‚Äôll step into the world of **GitHub**‚Äîa platform that helps us manage code collaboratively, no matter where we are.

Think about it: documentation gives us the story, design gives us the structure, and GitHub helps us collaborate and build the actual product. That is how software engineering flows like a complete cycle.

Would you like me to now connect these functional requirements‚Äîlike registration, catalog, or cart‚Äîdirectly with GitHub features such as issues, branches, and commits, so you can see how documentation turns into real teamwork?

Very good point you‚Äôve raised. Let me frame this in our mentor story style.

See, when we use the term *end user*, we should not get stuck with the idea that it always means the ‚Äúcustomer who purchases a product.‚Äù That‚Äôs only one type of end user. In reality, your system may have many kinds of users, and each of them has their own role and expectations.

For example, the **shopper**‚Äîthe seller on the platform‚Äîmay want to log in to update the inventory of products. He is also a user of the system. Then, think of the **sales manager** inside the organization. She may want to log in to view today‚Äôs revenue or generate sales reports. Again, she is also a user. And of course, the **customer**, the person browsing products and placing orders, is also a user.

So what do we learn from this? The word *customer* is specific, but the word *end user* is broader. End user could mean a customer, a staff member, a seller, or even an administrator. That‚Äôs why when drafting our functional requirements, we must carefully define the different roles and state what each role can or cannot do.

And there is another category worth noting: the **anonymous user**. These are the guest visitors. They don‚Äôt log in, but they can still browse the product catalog, view offers, or check deals. They have limited privileges. This is also part of functional requirements, because the system needs to handle such cases gracefully.

Now, when we start listing functional requirements, it should capture these variations clearly. For example:

* Anonymous users can browse the product catalog but cannot add items to the cart.
* Registered customers can log in, add products to cart, make payments, and track orders.
* Shoppers (sellers) can log in and update product inventory.
* Staff or managers can log in to view business reports, manage transactions, and generate receipts.

Do you see the richness here? Functional requirements are not just about ‚Äúwhat the customer does.‚Äù They describe **what the entire system should do, for every type of user**. That includes front-end interactions like browsing and payment, as well as back-end responsibilities like transaction management, report generation, and integration with other systems.

And here comes the key principle:
üëâ A functional requirement should always be written in the form of **‚Äúwhat the system should do‚Äù**. It is not about how you will code it, but what the system must deliver.

Now, one more thing to keep in mind. Once the SRS document is created, its stability depends on the process model you are following. In the **Waterfall model**, once signed off, the SRS is frozen. No changes are expected midstream. But in a **Spiral model**, the SRS is continuously refined based on customer feedback. And in **Agile**, every sprint has its own set of evolving requirements documented and reviewed.

So the SRS is always the **starting point**, but its flexibility depends on the methodology chosen. That‚Äôs why writing it carefully, capturing maximum details, and clearly stating the do‚Äôs and don‚Äôts becomes so important. It is the foundation stone of the entire development effort.

Would you like me to help you **draft a neat sample SRS functional requirement list** for this online shopping system, covering all the user roles we just discussed‚Äîcustomer, shopper, staff, and anonymous user‚Äîso that it looks like a real industry-ready document?

Excellent ‚Äî you‚Äôve now touched the most important distinction in your **SRS writing journey**:

üëâ *Functional requirements* are about **what the system will do**,
üëâ *Non-functional requirements (NFRs)* are about **how the system will behave**.
 

 
When you asked, *‚ÄúShould privacy policy go into functional requirements?‚Äù* ‚Äî the instinct is correct, but privacy is not really a ‚Äúfunction‚Äù like login, cart, or payment. Privacy is a **constraint** on how the system must operate. That moves it into the **non-functional** bucket.

Think of it this way:

* Functional requirement: ‚ÄúCustomer can log in with a username and password.‚Äù
* Non-functional requirement: ‚ÄúPasswords must be encrypted using AES-256 and never stored in plain text.‚Äù

See the difference? One says *what to do*, the other says *how to protect it*.

 

So, when we list non-functional requirements for our **online shopping system**, we are talking about **characteristics and qualities** of the system:

1. **Security** ‚Äì Authentication, authorization, encryption, protection from unauthorized access, fraud detection (like preventing credit card misuse).
2. **Reliability** ‚Äì System should be stable and handle transactions without losing data.
3. **Availability** ‚Äì The application should be available 24/7 with at least 99.9% uptime.
4. **Maintainability** ‚Äì The code should be modular, easy to update, extend, and reuse.
5. **Portability** ‚Äì The system should run across platforms (desktop, mobile, server environments) without issues.
6. **Safety** ‚Äì The system should not harm the user‚Äôs environment (e.g., no malware, no crashing devices).
7. **Efficiency** ‚Äì Good throughput, quick response time, and ability to serve thousands of concurrent users by using load balancing.
8. **Policy Compliance** ‚Äì The system should respect legal and tax rules of different countries, follow data protection laws (like GDPR), and keep customer data private.

 

Now, to anchor this with our **online shopping example**:

* An **anonymous user** can browse products, but only a **registered and authenticated user** can place an order.
* The **system must encrypt customer payment data** to ensure privacy and security.
* **Only the order owner** should be able to view or cancel their order.
* If the application is accessed in India, GST rules apply; if in the EU, GDPR compliance must be ensured.
* Even if 10,000 customers log in at the same time, the system should give fair response times by distributing load across servers.

 

So, the rule is clear:

* **Functional = features** (‚Äúwhat system should do‚Äù).
* **Non-functional = qualities and constraints** (‚Äúhow system should behave‚Äù).

Both are equally critical. If your system has all the functions but poor non-functional qualities, the project will fail. Imagine Amazon where login works, cart works, but the site crashes on Black Friday ‚Äî useless!
 

Imagine I‚Äôm sitting with you in the lab and we‚Äôre drafting this SRS document.

I pause for a moment and say:
‚ÄúLook, let‚Äôs think about one simple but powerful rule ‚Äî **end users should always interact with your system in the way you design it.** Not by backdoor tricks, not by code injections, not by any hidden API calls. Just through the **graphical user interface** you provide.

So, when you write your non-functional requirements, put it clearly:
üëâ *Only graphical user interface (GUI) access of the system should be permitted to the end user.*

Why do we write this line? Because this one sentence gives the developer a big hint:

* Don‚Äôt leave any unprotected endpoints lying open.
* Don‚Äôt allow someone to bypass the front-end and directly poke into the database.
* Don‚Äôt let anyone misuse an API without proper authentication.

This is the *kind of strategic clarity* a non-functional requirement brings. It doesn‚Äôt say *what feature* you‚Äôre building, but it says *how securely and consistently the system should behave.*

Now, let‚Äôs move further. Abhishek asks:
‚ÄúSir, can we also consider disabled people, like accessibility for them?‚Äù

I smile and reply:
‚ÄúYes, Abhishek, that‚Äôs a wonderful point. But here‚Äôs a golden rule ‚Äî **we don‚Äôt invent requirements ourselves.** We capture what the **customer** tells us. If Amazon‚Äôs business team clearly instructs us that their online shopping portal must be accessible for visually challenged users, then we put it under non-functional requirements. Otherwise, we don‚Äôt assume. Why? Because we are consultants, not decision-makers. Our job is to translate business needs into technical specifications, not to dictate features.‚Äù

This is why **senior analysts** usually handle requirement gathering. Juniors or freshers are not sent directly to these meetings. They might try to think like developers or suggest on behalf of the company ‚Äî and that can confuse everything. Experienced analysts know how to ask the right questions, listen carefully, and draw boundaries.

I give another analogy:
‚ÄúIf my student says, ‚ÄòSir, I want to become a software engineer,‚Äô then I know what modules and skills to teach. But if the student himself doesn‚Äôt know what he wants ‚Äî and I just keep teaching random topics ‚Äî then all my efforts are wasted. In the same way, if Amazon doesn‚Äôt know what they want, we cannot define their requirements. We can only ask guiding questions and let *them* decide.‚Äù

That‚Äôs why meetings with customers are often handled by **Business Analysts (BA)**. A BA goes to the customer‚Äôs office, observes how business is done manually, asks about pain points, and then gradually translates that into system requirements.

Now, back to our non-functional requirements list. Another big one is **portability**.

Think about it: Amazon‚Äôs online store must run everywhere ‚Äî on mobiles, laptops, desktops, tablets, different browsers, different operating systems. That means when we design, we must choose universal technologies.

So, how do we write this in our SRS?
üëâ *The system shall provide a standard user interface accessible on all common devices and browsers, using universal technologies like HTML, CSS, and JavaScript.*

This line again gives a developer clarity: don‚Äôt use something that works only in Internet Explorer, don‚Äôt build features that fail on mobile, and don‚Äôt force customers to install special plugins. Keep it portable, keep it universal.


üí° So, remember this:

* **Functional requirements = what the system does.**
* **Non-functional requirements = how well the system behaves under different conditions.**

And both together make the SRS a complete, living document.


‚ÄúFriends, today let‚Äôs imagine we are setting up our **online shopping system**.
Now, when we create such a system, it‚Äôs not only about writing code ‚Äî it‚Äôs about **thinking from all angles**.

üëâ First, think about the **end user**.
The customer might come with a desktop, a laptop, a tablet, or even a smart gadget like a Google Glass or a HoloLens tomorrow.
So, what should we do?
We should make sure our application is **portable**.
That means ‚Äî no matter what hardware, no matter what OS (Windows, Linux, Mac) ‚Äî the user should be able to access it easily, simply through a browser. That is why HTML, CSS, JavaScript remain so important; they ensure your app runs anywhere.

üëâ But wait, portability is only the beginning.
What about **interoperability**?
Technology will keep changing. Today it‚Äôs a mobile app, tomorrow it may be a smart watch or voice-driven interface.
So can our application adapt with **minimum changes**? That‚Äôs where interoperability comes in ‚Äî the ability of your system to plug into new environments without breaking down.

üëâ Now let‚Äôs go a little deeper ‚Äî **maintainability**.
Every system has two big pieces: the **frontend** (what users see) and the **backend** (where your database sits).
What if tomorrow your database gets corrupted?
You need backups, recovery processes, replication.
And for that, we don‚Äôt reinvent the wheel ‚Äî we rely on **commercial database servers** like MySQL, Oracle, PostgreSQL.
Similarly, your web layer sits on **servers** like Tomcat, IIS, Glassfish.
So as developers, we don‚Äôt just code ‚Äî we also plan how maintenance will be done easily in future.

üëâ And then comes a very interesting one ‚Äî **availability**.
If you are building an online shop, should it work like a ‚ÄúPuneri shop‚Äù ‚Äî only open from 10 to 1, then closed till evening?
Of course not!
Customers expect 24x7 uptime. That‚Äôs why we talk about **99.999% availability**.
Yes, there may be a tiny fraction of downtime, but overall the system must be always ready.

üëâ But here‚Äôs a twist.
If your customer is Chitale Bandhu (the famous sweet shop), and they say:
‚ÄúOur online shop will only be open between 10 and 7, because we don‚Äôt sell sweets at midnight‚Äù ‚Äî
then as developers, we must respect their **business rules**.
So don‚Äôt confuse **business availability** with **system availability**.
Your job is to make the system available as per the business needs.

üëâ Finally, let‚Äôs talk about **reliability**.
How do we ensure that users can trust the system?
Imagine your online shop uses a single Oracle server. If it crashes, everything stops.
That‚Äôs not reliable.
So we add a **failover mechanism** ‚Äî multiple servers with redundancy.
If one fails, the other takes over automatically.
It‚Äôs like in your classroom ‚Äî if one faculty is absent, another steps in to continue the lecture. The class goes on, smoothly. That‚Äôs reliability in practice.


So, my dear friends, when you draft an **SRS (Software Requirement Specification)**, don‚Äôt only write the *functional requirements* like ‚Äúadd to cart‚Äù or ‚Äúcheckout.‚Äù
Also capture these **quality attributes**: portability, interoperability, maintainability, availability, and reliability.

That‚Äôs what separates a **software engineer** from just a **coder**.‚Äù
 

‚ÄúFriends, let me tell you something about **reliability**.
Think about our own institute, **ISCSD**. Even when I, Ravi Tambade, am not available for a class, some other faculty steps in, delivers the session, and the students go back happy.
That‚Äôs what we call **reliability** ‚Äî the system doesn‚Äôt stop just because one piece failed.

üëâ In the software world, reliability means your system must not collapse when a single server or database crashes.
How do we achieve that?

* By **backups**. Your database must always have a reliable backup strategy.
* By **failover servers**. If one database server goes down, another automatically takes charge.
* By **regular updates and patches**. Because an outdated server is like an unlocked door for problems.

So, reliability is not just ‚Äúfailure-free‚Äù in theory. It‚Äôs about ensuring the system can recover quickly and continue serving without losing critical data.


Now, many of you think:
‚ÄòSir, functional requirements are the most important ‚Äî add to cart, place an order, login, logout‚Ä¶ that‚Äôs what matters, right?‚Äô
Yes, they are important. But, listen carefully‚Ä¶

üëâ A student may know **Java, C++, HTML, Database**. That‚Äôs a functional requirement.
But what if this student is *not punctual, not honest, not reliable*?
Will any company hire him? No.

üëâ On the other hand, imagine a student who is very **honest, trustworthy, polite, and communicative** ‚Äî but doesn‚Äôt know Java, C, DBMS.
Will any company hire him? Again no.

So, my friends, you need **both**.

* **Functional requirements** = technical skills.
* **Non-functional requirements** = qualities like reliability, availability, maintainability, security, honesty in real life.

In software too ‚Äî only when you have both, does the system become mature and usable.

Think of this:
üëâ A **coder** just translates requirements into lines of code and compiles them.
üëâ A **developer**, on the other hand, understands engineering, fundamentals, software design, non-functional requirements, and business expectations.

If you want to become **developers** (not just coders), you must master both **functional** and **non-functional requirements**.

So, my dear students, remember this:

* Backups and failovers give **reliability**.
* 24√ó7 uptime gives **availability**.
* Portability and interoperability give **future readiness**.
* Maintainability keeps the system healthy in the long run.
* And functional requirements deliver the visible features.

Together, they form the **soul of your SRS (Software Requirement Specification)**.

That‚Äôs how you grow ‚Äî not just into coders, but into real **software engineers**.‚Äù

 
üë®‚Äçüè´ **Secure Communication in Web Technology**

"Imagine this‚Ä¶ You are building an online shopping platform. A customer comes in, adds items to the cart, and proceeds to payment. Now pause here. The customer is about to enter their **credit card details**. If your website isn‚Äôt secure, that sensitive information can be read by anyone in between ‚Äî like someone eavesdropping in a crowded railway station.

This is where **SSL ‚Äì Secure Socket Layer** (today we use its modern version TLS) steps in. It acts like a **secret tunnel** between the customer‚Äôs computer and your server. Whatever goes inside that tunnel ‚Äî username, password, payment details, business reports ‚Äî is encrypted. Meaning, even if a hacker gets hold of it, it will look like random garbage, not useful information.

Now think of the little **padlock symbol üîí** you see when you open websites like *[https://amazon.in](https://amazon.in)*. That‚Äôs the proof that SSL/TLS is active. The ‚ÄòS‚Äô in HTTPS literally stands for *Secure*.

But security is not just about SSL. Once the user logs in with a username and password, the server issues a **token**. That token acts like an **entry pass**. Each time the user performs an action ‚Äî cancel order, place order, view sales reports ‚Äî that token is checked. If valid, the door opens. If missing, the user is redirected back to the login page. This is called **Token-based Authentication**.

Now let‚Äôs extend the story. What if a user logs in at a cyber caf√© and forgets to log out? Anyone could misuse their account. That‚Äôs why we set **session timeouts** and **auto-logout after inactivity**. It‚Äôs like a shopkeeper who locks the counter if the customer doesn‚Äôt return after some time.

Another important point ‚Äî we must ensure **no sensitive data like passwords are stored in cookies** on the client machine. Otherwise, hackers can easily misuse it.

And it‚Äôs not just client-to-server communication. Even **server-to-server communication** (say, between your web server and your database server) must be secured using authentication and encryption. Sensitive data in transit should never travel plain.

Still, is this enough? No. We also need **firewalls**. Think of them as the strong fortress walls around your data center, protecting your servers from unauthorized entry or denial-of-service attacks. Without firewalls, hackers can bring down your server or steal data.

Do you remember reading news about **Domino‚Äôs and Air India data breaches**? Millions of customer records ended up on the dark web ‚Äî names, phone numbers, even partial credit card details. Customers lose trust, and businesses lose reputation. That‚Äôs why your design document must clearly spell out **security as a non-functional requirement** ‚Äî not just a feature, but a promise to the customer.

So when you prepare your **SRS/SSD document**, don‚Äôt write it like poetry or Shakespeare‚Äôs play. Write it with precision. Mention:

* SSL/TLS must be used for *all* transactions.
* Token-based authentication must secure every request.
* Session timeouts and auto-logout after inactivity must be enforced.
* No sensitive cookies should remain on client machines.
* Server-to-server communication must use encryption.
* Firewalls must be installed to block malicious attacks.

That way, anyone who reads your document will immediately understand that your system isn‚Äôt just functional ‚Äî it‚Äôs **secure, trustworthy, and professional**."

üë®‚Äçüè´ **From Requirements to Professional SRS**

"Friends, let‚Äôs step into the shoes of a professional software team. You are not just students anymore ‚Äî you are preparing to be industry engineers. And in industry, before writing even a single line of code, there is one critical artifact: the **SRS document (Software Requirement Specification)**.

Now, who writes this? Not just developers. In fact, at this stage, the **developer doesn‚Äôt even enter the room**. The people who gather and shape the requirements are:

* **Customer** ‚Äì the one who has the problem and business need.
* **Architect** ‚Äì the one who ensures technical feasibility and future scalability.
* **Domain Expert** ‚Äì the one who deeply understands the business rules (like e-commerce, banking, healthcare).
* **Business Analyst** ‚Äì the bridge between customer and technical team.
* **QA (Quality Assurance)** ‚Äì the one who ensures that requirements are testable and measurable.

This team comes together and defines:

* **Title** ‚Äì e.g., *Online Shopping Solution*.
* **Date** ‚Äì when the document is prepared (say 24/5/2021).
* **Glossary of terms** ‚Äì SSL, HTML, RDBMS, QA, PDF, etc., so that no one misunderstands abbreviations.

Then comes the **heart of the document**:

1Ô∏è‚É£ **Purpose & Scope** ‚Äì Why are we building this system? What problem does it solve? Who are the users?

2Ô∏è‚É£ **Functional Requirements** ‚Äì These are the features. For an online shopping solution, this includes:

* Login & Registration
* Product Catalog
* Shopping Cart
* Payment Gateway
* Order History
* Shipping Details
* Account Settings
* Filters & Promotions

Each of these can later be mapped into **DFDs (Data Flow Diagrams)**. For example:

* *Input*: username + password
* *Process*: login/authentication
* *Output*: success ‚Üí token generated, failure ‚Üí error message

3Ô∏è‚É£ **Non-Functional Requirements** ‚Äì This is where **professionalism shines**. Most students stop at functional requirements. But industry asks:

* **Security** ‚Äì Use SSL/TLS for all transactions. Token-based authentication for each request. Session timeout and auto-logout after inactivity. No sensitive cookies stored on client machines. Firewalls to protect servers. Server-to-server communication encrypted.
* **Performance** ‚Äì System should handle concurrent users without delay.
* **Portability** ‚Äì Should work across devices (desktop, mobile).
* **Reliability** ‚Äì Data must not be lost. System should recover from crashes.
* **Maintainability & Scalability** ‚Äì Easy to extend when business grows.

üìå And remember, these non-functional requirements are not "add-ons". They are the **trust-building layer**. If customers don‚Äôt trust your site (after hearing about Domino‚Äôs or Air India data breaches), they won‚Äôt shop with you, no matter how beautiful your product catalog is.

Now, once all this is captured, the SRS is **shown to the customer**. If the customer agrees and signs, only then the baton passes to the **design team and developers**. Notice ‚Äî till now, no programming language is even mentioned. Whether it will be C#, Java, or Python is irrelevant here. The SRS must be **technology-independent**.

Why are we practicing this in EDAC/C-DAC? Because industry doesn‚Äôt hire you just for writing syntax. They need engineers who can **think systematically, capture requirements, and document them professionally**. This ability sets you apart from being just a coder to becoming a **software engineer**.

So remember my golden line:
üëâ *Do ordinary things extraordinarily.*
Login page is ordinary. Cart is ordinary. Payment is ordinary. But if you define them clearly, securely, and professionally in your document ‚Äî you are no longer ordinary. You are industry-ready.

And tomorrow, in an interview, when someone asks, *‚ÄòHave you written an SRS document?‚Äô* ‚Äî you don‚Äôt just say yes. You share your GitHub link where your document is kept. That‚Äôs when the interviewer silently smiles and thinks, *‚ÄòThis candidate understands the real process of software engineering.‚Äô*

That‚Äôs the difference we are building here."

 
üë®‚Äçüè´ **From SRS to Object-Oriented Analysis**

"Friends, now that you understand **SRS thoroughly** ‚Äî the functional and non-functional requirements, glossaries, diagrams, and customer verification ‚Äî let‚Äôs move to the **next phase: Analysis and Design**.

Remember, **your SRS is the only input for this phase**. Many beginners make the mistake of adding assumptions, personal ideas, or coding shortcuts. Don‚Äôt do that. The goal here is **to transform what is in the SRS into a design that developers can implement**.

Here‚Äôs how you approach it naturally:

Imagine a real-world problem ‚Äî I need to go from my home to **ICSD** to conduct a session.

1. **Problem Definition:** Go to ICSD and conduct the session.
2. **Think Naturally:**

   * How far is ICSD? ~35 km.
   * How do I travel? Options: personal car, bike, public transport.
   * Public transport? Options: bus, train, metro (still under construction), so I choose train.
   * From Shivaji Nagar station, I walk to ICSD.
   * What do I need to conduct the session? Laptop, projector, agenda.

Notice the process: **I broke down a problem naturally into entities and actions.**

‚û° **This is exactly how we identify objects in OOAD:**

* Bike ‚Üí Object
* Train ‚Üí Object
* Train Ticket ‚Üí Object
* Laptop ‚Üí Object
* Projector ‚Üí Object
* Agenda ‚Üí Object

Each object has **attributes** and **behaviors**.

* Laptop ‚Üí Attributes: brand, RAM, OS. Behavior: connect to projector, run software.
* Train Ticket ‚Üí Attributes: seat number, source, destination. Behavior: validate, print.

This approach ‚Äî **natural problem-solving ‚Äî is the cornerstone of OOAD.** You observe the real-world scenario, identify objects, and map **inputs, processes, outputs**. Just like we did in DFDs, but now **thinking in terms of objects and their interactions**.

‚úÖ **Key Takeaways:**

* Analysis phase is purely based on **SRS inputs**. No assumptions, no shortcuts.
* Identify **objects** by examining real-world scenarios or use cases.
* Define **attributes** (data) and **behaviors** (functions/methods) for each object.
* This is the foundation for **class diagrams, sequence diagrams, and other UML models**.

Next, we will translate these objects into **UML diagrams** ‚Äî class diagrams, use case diagrams, and sequence diagrams ‚Äî so that developers know **exactly what to implement**.

Remember: **SRS is your map, OOAD is your path to the solution.**

 
 
### **From Natural Thinking to OOAD**

**1. Solving Problems Naturally**
When we want to achieve a goal, we naturally identify the **things (objects)** we need and the **processes** to achieve it.
Example: Conducting a session at CDAC.

* Identify objects: Laptop, projector, agenda, train ticket, bike.
* Identify actions (behaviors): Travel, use projector, present slides.
* Identify state: Train type, laptop OS, ticket details.

**2. What is an Object?**
An **object** is a **real-world, tangible entity** with:

* **State:** Attributes that describe it (train ticket: seat number, source, destination)
* **Behavior:** Actions it can perform (laptop: run presentation, connect to projector)
* **Identity:** Distinguishable from other objects (your laptop vs someone else‚Äôs laptop)

> This is exactly how humans naturally think and solve problems.

**3. OOAD: Applying Natural Thinking in Software**
Object-Oriented Analysis and Design is nothing but **formalizing this natural way of thinking** for software.

* OAA / OOAD = OPSEC (Object-Oriented Problem Solving with natural thinking)
* Implementation can be in any programming language: Java ‚Üí OO Java, Python ‚Üí OO Python, etc.
* Concept comes first; language is just a tool to implement it.

**4. Pillars of Object Orientation**
**Major pillars:**

1. **Abstraction** ‚Äì Focus on essential features, hide unnecessary details
2. **Encapsulation** ‚Äì Bundle data and behavior; protect state
3. **Inheritance + Polymorphism** ‚Äì Reuse code, extend behavior, one enables the other

**Minor pillars:**

1. **Modularity** ‚Äì Organize system into self-contained units
2. **Persistence** ‚Äì How objects maintain state
3. **Hierarchy** ‚Äì Class relationships and structures
4. **Concurrency** ‚Äì Parallel operations
5. **Typing** ‚Äì Correct use of data types and type safety

**5. Relationships Between Objects**

* **Association** ‚Äì Simple connection between objects
* **Aggregation** ‚Äì Whole-part relationship where part can exist independently
* **Composition** ‚Äì Strong whole-part relationship; parts cannot exist without whole
* **Example:** H2O (water) is composition of hydrogen + oxygen ‚Üí cannot exist independently as H2O without both

**6. Applying OOAD to Online Shopping Application**

* Identify objects: Product, Cart, Order, User, Payment
* Identify attributes (state): Product ‚Üí name, price, stock
* Identify behaviors: Cart ‚Üí addProduct(), removeProduct(), calculateTotal()
* Define relationships: User owns Cart (aggregation), Order contains Products (composition)
* Design using **class diagrams, sequence diagrams, and use case diagrams**

üí° **Key Idea:** OOAD is just **solving software problems the way humans solve real-life problems**, by identifying objects, their states, behaviors, and relationships ‚Äî then formalizing them for implementation.



### **1Ô∏è‚É£ Abstraction ‚Äì ‚ÄúSelective Ignorance‚Äù**

**Definition:**
Abstraction is **capturing only the essential characteristics of a system** depending on the perspective of an observer. Ignore irrelevant details.

**Key Idea:** Select what‚Äôs important, hide the rest.

**Example ‚Äì Online Shopping Application:**

* **Observer:** End-user shopper

  * Essential: Product catalog, adding items to cart, placing orders, payment.
  * Ignore: Internal inventory calculations, database queries, payment gateway internals.
* **Observer:** Staff

  * Essential: Manage orders, update inventory, approve cancellations.
* **Observer:** Admin/Board of Directors

  * Essential: Business dashboards, reports, top-selling products.

**In practice:** Writing your **SRS (Software Requirement Specification)** is essentially applying abstraction. You define **what the system should do**, not how it does it internally.



### **2Ô∏è‚É£ Encapsulation ‚Äì ‚ÄúHiding Complexity‚Äù**

**Definition:**
Encapsulation is **hiding the internal complexity of a system** so users interact through a simplified interface.

**Analogy:**

* **TV Remote Control:** You don‚Äôt need to know how the circuitry works; you just press buttons to change channels or volume.
* **Capsule Medicine:** Bitter medicine powder is hidden inside a capsule; user takes it easily without tasting the bitterness.

**Example ‚Äì Online Shopping Application:**

* **Payment Gateway:** User clicks ‚ÄúPay,‚Äù but the internal steps (auth, transfer, encryption) are hidden.
* **Shopping Cart Management:** User adds products, but session handling, storage, and timeout mechanisms are hidden.
* **Order Processing:** Workflow, approvals, and cancellations are complex internally but exposed as simple actions to users.

**Implementation in code:** `public` and `private` access specifiers hide data and methods, exposing only what is necessary.


### **3Ô∏è‚É£ Inheritance ‚Äì ‚ÄúReusability‚Äù**

**Definition:**
Inheritance is creating **hierarchies** where child entities reuse properties and methods from parent entities.

**Example ‚Äì Online Shopping Application:**

* **Parent Class:** `User` (common properties like Name, Email, Password)
* **Child Classes:** `Customer`, `Staff`, `Admin` ‚Äì each inherits common properties and adds their own functionality.

**Result:** Reduces redundancy, organizes code hierarchically, enables polymorphism.


### **4Ô∏è‚É£ Modularity**

**Definition:**
Design the system as **independent, reusable modules**.

**Example ‚Äì Online Shopping Application:**

* Frontend module
* Backend module
* Business logic module
* Authentication module
* Payment module

**Benefit:** Easier maintenance, testing, and future expansion.


### **5Ô∏è‚É£ Persistence**

**Definition:**
Preserve the **state of objects** across program executions.

**Example ‚Äì Online Shopping Application:**

* Shopping cart persists in database even if the session expires.
* User data and order history stored in secondary storage (database).


### **6Ô∏è‚É£ Hierarchy**

**Definition:**
Organize entities, functions, or modules in a **tree-like structure**.

**Example:**

* Class hierarchy: `Product` ‚Üí `Electronics` ‚Üí `Mobile Phones`
* Order workflow: `Order` ‚Üí `Processing` ‚Üí `Approval` ‚Üí `Dispatch`


### **7Ô∏è‚É£ Concurrency**

**Definition:**
Perform **multiple tasks at the same time**.

**Example ‚Äì Online Shopping Application:**

* Thousands of users placing orders, canceling orders, browsing products simultaneously.
* Handled using multithreading, parallelism, or concurrent processing.

**Analogy:** Processor switches tasks in microseconds so it **feels like all tasks are happening simultaneously**.


### **8Ô∏è‚É£ Typing**

**Definition:**
Assign specific **data types** to your entities.

**Example ‚Äì Online Shopping Application:**

* `CustomerID` ‚Üí Integer
* `ProductPrice` ‚Üí Decimal
* `IsAvailable` ‚Üí Boolean
* `ShoppingCart` ‚Üí User-defined class



### ‚úÖ **Summary Table ‚Äì Applying OOP Principles in Online Shopping**

| Principle     | Meaning/Action                           | Example in Shopping App                   |
| ------------- | ---------------------------------------- | ----------------------------------------- |
| Abstraction   | Select essential features                | Show product catalog, ignore DB queries   |
| Encapsulation | Hide complexity, expose simple interface | Payment gateway, shopping cart management |
| Inheritance   | Reuse and hierarchy                      | `User` ‚Üí `Customer`, `Staff`, `Admin`     |
| Modularity    | Independent reusable modules             | Frontend, backend, payment, auth modules  |
| Persistence   | Maintain object state across sessions    | Shopping cart, order history              |
| Hierarchy     | Organize logically in tree structure     | Product categories, order workflow        |
| Concurrency   | Multiple tasks at once                   | 10,000+ users placing orders concurrently |
| Typing        | Define data types clearly                | Integer, Decimal, Boolean, Classes        |

