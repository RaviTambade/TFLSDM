## 🌱 Setting the Stage for Source Control Management (Git and GitHub)

“Class, today I want to tell you a story… Imagine you and your friends are **writing a book together**. Everyone is working on **different chapters**, but there’s only **one copy of the book**. What could go wrong?”

* Someone accidentally **erases a paragraph**.
* Two people edit the **same page** and overwrite each other’s work.
* You want to **see the previous version** because the new one has a mistake.

This is exactly what happens in **software development**. Multiple developers, multiple files, multiple changes—chaos without **Source Control Management (SCM)**.


### 1️⃣ What is SCM?

SCM is like a **magical diary and librarian combined**.

* It **keeps track of every change** in your code.
* It allows you to **go back in time** to any previous version.
* It allows **multiple people** to work together without destroying each other’s work.
* It also **logs who did what, when, and why**.

Think of it as the **GitHub of history** for your code.


### 2️⃣ Core Benefits:

#### 🔹 Collaboration Made Easy

* Each developer can work on **their own copy** (branch).
* Changes are **merged** into the main code once tested.
* No more “my code vs your code” fight.

#### 🔹 Version History

* Every change is **saved as a commit**.
* If something breaks, you can **revert to a working version** instantly.

#### 🔹 Accountability & Transparency

* SCM tells you **who wrote which line of code**.
* Helps during code reviews and bug investigations.

#### 🔹 Supports Agile & Continuous Delivery

* In Scrum or Kanban, SCM allows you to **track features per branch, per sprint**.
* CI/CD pipelines use SCM to **build, test, and deploy automatically**.

#### 🔹 Backup & Safety

* Your code is **never lost** even if your laptop crashes.
* Central repository (like GitHub, GitLab, Bitbucket) keeps a **safe copy** in the cloud.

### 3️⃣ How I Explain to Students:

I usually use a **story-driven analogy**:

1. **Local Notebook = Developer Machine**

   * You make notes (code changes) in your notebook.
2. **Library = Central Repository**

   * You submit your notes to the library (commit/push).
3. **Branching = Separate Chapters**

   * Each chapter is a branch. You can write your chapter independently.
4. **Merging = Assembling the Book**

   * Once chapters are ready, you merge into the main book (main/master branch).
5. **Version History = Time Machine**

   * Every edition of your book is saved. You can always go back.
 

### 4️⃣ Example in Real Life

* Imagine a team of 5 developers building an **e-commerce website**.
* Alice works on **payment module**, Bob works on **cart module**, Charlie works on **UI**.
* Without SCM: They overwrite each other’s changes, chaos ensues.
* With Git (SCM): Each works on their branch. Alice merges payment, Bob merges cart, Charlie merges UI. **Main branch is always deployable**.
 

### 🔹 Mentor Tip

SCM is not just a tool—it’s a **discipline**.

* Commit often.
* Write meaningful commit messages.
* Pull before you push.
* Use branching strategy (feature/bugfix/hotfix).

This **small habit** separates a junior developer from a productive Agile developer.

Think of GitHub like your **digital diary of code**.

* You write something in your diary (your local machine).
* To keep it safe and shareable, you also copy it into a locker (GitHub).
* Now, if someone else—or even your future self—wants to read it, they just need access to that locker.

That’s why companies ask in interviews: *“Do you have a GitHub account?”* Because GitHub is no longer just about storage—it’s a reflection of your coding journey.



### 🛠️ Hands-On Flow for Today

We’ll go step by step:

1. **Clone the Repository** (bring it from GitHub to your laptop)

   ```bash
   git clone <repo-url>
   ```

2. **Check Repo Status** (are there any changes?)

   ```bash
   git status
   ```

3. **Make Small Changes** (edit a file, maybe add a comment in Java or SQL).

4. **Stage Your Work** (tell Git: “I want to track these changes”)

   ```bash
   git add <filename>  
   # or all changes  
   git add .
   ```

5. **Commit the Changes** (take a snapshot with a meaningful message)

   ```bash
   git commit -m "Added booking table script in SQL"
   ```

6. **Push Back to GitHub** (send your snapshot back to the locker)

   ```bash
   git push origin main
   ```

💡 *Main* is the default branch for most repos now. Some older ones still use *master*.

---

### 📖 Story Link to Development

Imagine you’re building a **mini online ticket booking project**:

* Java code for business logic
* SQL files for tables
* Maybe a small script for automation

If all these files just sit on your laptop, only you know about them. But the moment you put them into GitHub:
✅ Your peers can review
✅ You can show them in interviews
✅ Recruiters see your seriousness
✅ You always have a backup


### 🌟 Mentor’s Suggestion

* Don’t just create one repository. Create **3–4 small mini projects** as public repositories.
* Give each repo a **clear name and description**:

  > *“This repo contains source code for a demo Online Ticket Booking app (Java + SQL + basic frontend).”*

That way, when a recruiter looks at your GitHub, they immediately know:
👉 “This candidate didn’t just learn theory—they built something hands-on.”



### 🚀 Exercise for You

Before the next session:

1. Create a new public repo on GitHub called **OnlineTicketBooking**.
2. Add a simple `README.md` describing the project.
3. Push one `.java` file or `.sql` script into it.
4. Share your GitHub URL in our classroom group.

By doing this, you’re not just learning Git commands—you’re also **building your coding portfolio** step by step.



So friends, now we have reached a very important turning point in our hands-on.

You all saw that we modified the file **`readIO.js`** in our developer environment.
When we check in Windows Explorer or VS Code, the timestamp clearly shows – “Modified just now.”

But, when we open our GitHub repository in the browser… what do we see?
👉 The file is still showing “Modified yesterday.”

Now the million-dollar question:
🔹 Why is GitHub not showing my updated code?

The answer is very simple – **Git is not an automatic synchronizer.**
It doesn’t instantly upload your changes to GitHub.
Instead, it follows a **three-step discipline**:


### 🛠️ Step 1: `git add`

Think of it like this –
you have written your notes in a notebook, but before submitting to the teacher, you first have to put them in a folder.

In Git terms, you are staging your changes:

```bash
git add readIO.js
```

This tells Git: “Hey Git, I am ready with this file, keep it in your bag for submission.”

If you want to add *all modified files* at once:

```bash
git add .
```


### 🛠️ Step 2: `git commit`

Now staging is done, but still the teacher (GitHub) doesn’t know.
So you must **commit**, which is like signing the folder with a message.

```bash
git commit -m "Updated readIO.js with counter logic"
```

This creates a snapshot of your code history in your **local Git repository**.
Still it is on your machine only, not yet on GitHub.


### 🛠️ Step 3: `git push`

Finally, you have to push your snapshot to the central repository (GitHub).

```bash
git push origin main
```

Here:

* `origin` = name of the remote GitHub repository
* `main` = default branch (earlier it used to be `master`)

Once you push, only then GitHub will show “Modified just now.”


### 🔄 Quick Recap of Workflow

1. **Edit files** → changes exist in your *working directory*.
2. **git add** → moves changes to the *staging area*.
3. **git commit** → saves a snapshot in your *local repository*.
4. **git push** → uploads commits to the *remote repository (GitHub)*.

So GitHub always shows the **last pushed state**, not what is in your local machine.


💡 *Mentor Tip:*
If you miss the push step, your GitHub stays outdated – and during an interview if you share your repo, the interviewer will never see your latest hard work.




## 🎯 Advantages of Git Branching in Agile/Scrum

### 1️⃣ Isolation of Features

In Scrum, we work in **sprints**, delivering small chunks of functionality.

* Each feature, bug fix, or experiment can go into its **own branch** (`feature/login`, `bugfix/cart` etc.).
* This ensures your **main branch (trunk)** is always **stable**, so the product can be deployed at any moment if needed.
* Think of it as: you are building a room on a treehouse without shaking the entire tree.



### 2️⃣ Parallel Development

Agile teams often have **multiple developers working simultaneously**.

* Developer A works on **payment integration**, Developer B works on **user profile**.
* They can create separate branches. No one blocks the other.
* Once ready, branches are merged into `main`.

**Result:** Faster delivery, less code conflict, smoother sprint execution.



### 3️⃣ Easier Code Reviews and Quality Checks

In Scrum, we emphasize **code review and continuous integration**.

* With separate branches, you can open **Pull Requests (PRs)**.
* Team members can review your code before it touches the main branch.
* CI/CD pipelines can run tests automatically for that branch.

**Benefit:** Bugs are caught early, quality stays high.



### 4️⃣ Experimentation Without Risk

Sometimes Agile teams **experiment with new ideas**:

* Create a branch (`experiment/new-ui`) to test a new layout or logic.
* If it fails, just delete the branch. `main` stays safe.
* Encourages innovation while keeping production stable.



### 5️⃣ Clear History and Traceability

Scrum emphasizes transparency. Branches give:

* **Commit history per feature** – “This branch added login functionality.”
* **Traceability** – You can track which sprint, task, or Jira ticket each branch relates to.
* **Metrics for retrospectives** – How many features completed, average time to merge, etc.


### 6️⃣ Supports Agile Practices

* **Sprint planning & backlog:** Each backlog item → one branch. Easy tracking.
* **Daily standups:** “I’m on branch `feature/cart-discount`” → everyone knows your focus.
* **Sprint demo / review:** Merge completed branches → deploy → demo to stakeholders.

 

### 7️⃣ Quick Hotfixes

* A critical bug is discovered during a sprint or in production?
* Create a `hotfix/<bug>` branch from `main`, fix it, merge it back to `main` (and optionally to active feature branches).
* No disruption to ongoing work in sprint branches.

 

### 8️⃣ Collaboration with Less Conflicts

* Frequent branch merges + small commits → fewer conflicts.
* Git can intelligently handle changes.
* Agile emphasizes **continuous integration**, so branching aligns perfectly with CI/CD workflows.

 

### 🔹Branching:

In Scrum, treat **branches like mini sprints**.

* Each branch has a goal, a small scope, and a timeline.
* Merge frequently, commit often.
* Keep `main` always production-ready.

 


# 1) Why branching?

Short answer: **isolation + safety + collaboration**.

* Work on a feature without breaking `main`.
* Let several developers work in parallel.
* Keep small, focused changes so reviews are easier.

Real story: you’re adding **seat-selection** to the OnlineTicketBooking app. You create a branch `feature/seat-selection`, build and test there — the live site (main) stays stable.


# 2) Branch types & naming (simple rules)

Use short, semantic names — everyone understands immediately.

Common prefixes:

* `feature/<name>` — new feature (e.g. `feature/seat-selection`)
* `bugfix/<id>-<short>` — fix a bug (e.g. `bugfix/123-fix-price-calc`)
* `hotfix/<short>` — urgent production fix
* `release/<version>` — prepare a release
* `chore/<short>` — tasks, docs, infra

Keep names lowercase, use hyphens, be consistent.

---

# 3) Basic commands — create, switch, inspect

Create and switch to a new branch:

```bash
# modern (recommended)
git switch -c feature/seat-selection

# older / compatible
git checkout -b feature/seat-selection
```

See branches:

```bash
git branch          # local branches
git branch -a       # local + remote branches
```

Show commit history graph (simple):

```bash
git log --oneline --graph --decorate --all
```

---

# 4) Daily workflow for a feature (step-by-step)

1. **Start from a clean main**

```bash
git checkout main
git pull origin main   # ensure latest
```

2. **Create a branch**

```bash
git switch -c feature/seat-selection
```

3. **Do work** (edit files in VSCode / editor)

4. **Stage & commit frequently**

```bash
git add .
git commit -m "feat: add seat-selection UI and model"
```

5. **Push branch to remote (first time set upstream)**

```bash
git push -u origin feature/seat-selection
```

6. **Open a Pull Request (PR)** on GitHub/GitLab pointing `feature/seat-selection` → `main`. Ask for review.

7. **Keep branch up to date** while you wait for review — either merge or rebase `main` into your branch (see section below).

8. **After review**, merge the PR in the remote (use merge commit / squash / rebase according to team policy).

9. **Clean up**

```bash
# delete local
git branch -d feature/seat-selection

# delete remote
git push origin --delete feature/seat-selection
```

# 5) Keeping your branch up to date — merge vs rebase

When `main` moves forward while you work, you have two common ways to integrate those changes into your branch.

Option A — **merge** (preserves history)

```bash
# on your branch
git fetch origin
git merge origin/main
# resolve conflicts if any, commit
```

Good when you want explicit history showing merges.

Option B — **rebase** (linear history)

```bash
git fetch origin
git rebase origin/main
# resolve conflicts, then git rebase --continue
```

Rebase rewrites your branch commits so they look like they started from latest `main`. Cleaner history, but don’t rebase public (shared) branches.

Guideline: For private feature branches you intend to push only once, rebasing before merging makes the main history linear and tidy. If you already shared branch with others, prefer merging or coordinate the rebase.


# 6) Handling merge conflicts (practical steps)

Conflicts happen — be calm.

1. Git tells you which files conflict.
2. Open the file — you’ll see conflict markers:

```text
<<<<<<< HEAD
changes from target (e.g., main)
=======
changes from your branch
>>>>>>> feature/...
```

3. Edit to resolve (choose, combine, or rewrite).
4. Mark resolved:

```bash
git add <file>
# if merging:
git commit          # if merge created STOPPED state; otherwise merge auto commit
# if rebasing:
git rebase --continue
```

5. `git status` helps at each step.


# 7) Pull Requests & Code Review (best practice)

* Small PRs = faster review. Aim for < 300 lines.
* Use clear PR title and description: what changed, why, testing done.
* Attach screenshots or demos if UI changed.
* Ask 1–2 reviewers. Address comments in the same branch and push fixes.
* After approval, merge using your team’s strategy (squash merges keep main tidy).

# 8) Hotfix workflow (urgent)

When production needs a fix:

1. Branch off `main`: `git switch -c hotfix/patch-issue`
2. Fix, commit, push.
3. Create PR to `main`, merge, deploy.
4. Also merge the hotfix into `develop` or other long-lived branches so the fix is not lost.


# 9) Quick commands cheat-sheet

Create and push:

```bash
git switch -c feature/xyz
# work...
git add .
git commit -m "feat: xyz"
git push -u origin feature/xyz
```

Update from main (merge):

```bash
git fetch origin
git merge origin/main
# resolve conflicts → commit
```

Update from main (rebase):

```bash
git fetch origin
git rebase origin/main
# resolve conflicts → git rebase --continue
```

Delete branches:

```bash
git branch -d feature/xyz
git push origin --delete feature/xyz
```

Undo last commit but keep changes (soft reset):

```bash
git reset --soft HEAD~1
```

View remote branches:

```bash
git branch -r
```

Show current branch:

```bash
git branch --show-current
```

# 10) Classroom mini-lab (3 exercises)

1. **Create & push a feature**

   * `git switch -c feature/hello`
   * create `hello.txt` with your name
   * `git add . && git commit -m "add hello.txt"`
   * `git push -u origin feature/hello`
   * Open a PR to `main`.

2. **Simulate conflict**

   * Person A edits `config.txt` on `main` and pushes.
   * Person B (you) edits same line on `feature/conflict` and tries to merge `origin/main` → you’ll get conflict. Resolve it, finish merge, push.

3. **Hotfix**

   * Branch `hotfix/typo`, fix a README typo, open PR, merge to `main`, and then delete branch.


# 11) Best practices / mentor tips

* Create a branch for every task (no long-lived personal branches).
* Keep branches short-lived (days to a few weeks). Merge often.
* Commit small, focused changes with meaningful messages.
* Protect `main` — require PRs and reviews before merge.
* Use CI to run tests on every PR so merges are safe.
* Use `git status` & `git log --oneline --graph` — they’re your friends.
