# *Why Software Engineering Principles Matter*

**So let us get started…**

You know, I want to begin today by making you a little comfortable. Let me first touch upon something that I know many of you feel deep inside.

Whenever we hear the term *Software Engineering*, what comes to mind?
Most of you must be thinking: *“Oh, that theory subject… good for scoring marks in exams, nothing beyond that.”*

And I must tell you—that is one of the biggest misconceptions in computer science.

Software engineering is **not a subject for marks**.
It is the **foundation** of everything you will do as a software engineer.
Without it, even the strongest programming skills won’t take you very far.


### Programming Languages ≠ Software Development

Now let me give you another perspective.
All of you have learned programming languages. Some of you love **C**, some are strong in **C++**, others like **Java** or **C#**, and nowadays many are drawn towards **JavaScript** or **TypeScript**.

But let me tell you honestly—languages are just *tools*.

Think about it:

* Once upon a time, **C** was the king. Excellent for system-level software.
* Then came **C++**, which brought in **object orientation**—now we could design more complex business applications.
* Later, **Java** became the universal choice for Internet applications, and **C#** followed closely, almost like a cousin of Java.
* Today, you see **JavaScript, TypeScript, Python, Go**—languages keep evolving, syntax keeps changing.

So, does mastering one language mean you’re a great software engineer?
Sorry… no.
Languages change. The real maturity lies in your ability to **design software, architect solutions, and follow engineering principles.**


### Beyond Syntax: The Blueprint Analogy

Let me give you an analogy.

Imagine building a house.
Would you ever say: “I have bricks, I have cement, I have iron rods—let’s start building”?

No.
A civil engineer will first create a **blueprint**.
Depending on requirements, he’ll plan a **2BHK flat, a bungalow, a duplex, or a high-rise apartment**.

Similarly in software—your **programming language** is just cement, bricks, and rods.
Your **libraries** are ready-made doors, windows, and electrical fittings.
But without a **design blueprint**, nothing meaningful can be built.


### Libraries and Frameworks: The Ready-Made Tools

Let me touch on this too.

In every language, you’ve seen **libraries**:

* In C: `stdio.h`, `fopen()`, `fclose()`
* In C++: `iostream`, STL
* In Java: `java.io`, `java.lang`
* In JavaScript: **jQuery**, or today’s React/Angular libraries

Libraries give you **ready-made functions, classes, and interfaces** so you don’t reinvent the wheel.

But then comes the **framework**—that’s like a full building plan already optimized for certain kinds of construction.

Examples?

* **MVC (Model-View-Controller)**
* **MVVM (Model-View-ViewModel)**
* **Spring Boot** in Java
* **ASP.NET Core MVC** in C#
* **Express.js** for Node.js
* **Laravel** for PHP

Frameworks are not just libraries—they are **architectural patterns** that guide how your entire software should be structured.

### The Real Takeaway

So my dear friends—don’t fall into the trap of saying:
*“If you know C, you can do anything.”*
or
*“If you’re good at Java, your career is safe forever.”*

That’s outdated thinking.

Instead:

1. Learn your language well.
2. Understand **object orientation** deeply.
3. Then, move on to **software engineering principles**—SDLC, design patterns, architecture, testing, deployment.
4. Finally, explore **frameworks**—they’ll make you industry-ready.

That’s the journey from **coder → software developer → software engineer**.
 

## *Languages, Libraries, Frameworks & Runtimes*

**I’m happy to know from your side…**

See, you’ve already mentioned so many names—Laravel, Django, Flask, Express.js, WordPress, Angular, React, Vue. Excellent! You know the buzzwords. But let us pause for a moment and understand clearly:

* **Node.js** is *not* a framework, my dear friends.
  It is a **runtime**.
* **Express.js** is the framework on top of Node.js.
* **Flask** and **Django** are Python frameworks.
* **Laravel** is a PHP framework.
* **Angular, React, Vue.js**—these are **front-end frameworks** (well, React is actually a *library*, but people often call it a framework).

So, language, library, framework—they’re all different. And we can’t mix them up.

### Why Do We Need Frameworks?

Now, let me ask you a question.
*Why do we even use frameworks?*

Think of it like this:

* A **library** is like a ready-made toolkit. In Java, you had `java.io`. In C, you had `stdio.h`. In JavaScript, you had jQuery. These are functions and classes someone else has already written for you.
* A **framework** is bigger. It is a **well-proven structure**, a kind of *blueprint*, that helps you organize your entire software project.

Remember my earlier civil engineering example?

* A **2BHK** flat is a framework.
* A **3BHK** flat is another framework.
* A **penthouse** is yet another.

Depending on what you want to build, you pick the right framework.

In software, frameworks do the same. For example, **MVC framework** gives you a proven way to separate Model, View, and Controller. **Spring Boot**, **ASP.NET MVC**, **Django**—all of them give you these standard structures.

So when you hear the word **framework**, always think: *“Ah, this is the skeleton, the standard way of organizing my code.”*

### Languages, Libraries & Frameworks Together

Now let’s connect the dots.

* **Programming languages** give you syntax: variables, loops, classes, object orientation.
* **Libraries** give you ready-made pieces: functions, classes, jar files, DLLs.
* **Frameworks** give you a well-proven **structure** for writing your application.

So, when you build software, you always use:
➡️ **Language + Libraries + Framework**

But one more thing is needed.

### What is a Runtime?

Tell me—have you heard about Java Runtime, Python Runtime, Node.js Runtime, .NET Runtime?
Yes, we always say: *“Install Java Runtime Environment”* or *“Install Node.js runtime”*.

But what does it mean?

A **runtime** is nothing but an **execution environment**.
It is the layer that takes your compiled (or interpreted) code and runs it on your operating system.

For example:

* In Java, you write `.java` files. They are compiled into `.class` files. But `.class` files cannot run directly. You need **JRE (Java Runtime Environment)**, which provides **JVM (Java Virtual Machine)** to execute them.
* In Python, you need the **Python runtime**.
* In Node.js, you need the **Node runtime**.
* In C#, you need the **.NET runtime**.
* Even in C and C++, the OS provides **native runtime libraries** (like in Windows or Linux) so that your binaries can run.

So runtime = **the environment where your code actually comes alive**.

### Final Picture

Now you see the complete flow:

1. **Language** → gives you syntax to write code.
2. **Libraries** → give you ready-made functions and classes.
3. **Frameworks** → give you a proven structure for building applications.
4. **Runtime** → gives you the execution environment to run your application.

Without **software engineering principles**, all these things—languages, libraries, frameworks, runtimes—are directionless. Principles give you the **blueprint, methodology, and discipline** to use these tools effectively.

## *Runtime, IDE, and Environments*

**So by default, friends…**

When you were learning C in college, you never asked: *“Where is my runtime?”* Because in C, the **native runtime** is already part of your **operating system**.
That means, when you compile a `.c` program into an `.exe` (on Windows) or into a binary (on Linux), the operating system itself has the libraries to execute it.

But today, in modern languages, we clearly differentiate between:

* **Operating System (OS)**
* **Execution Environment (Runtime)**

For example:

* Your **Java code** cannot run if there is no **Java Runtime Environment (JRE)**.
* Your **Python code** cannot run if there is no **Python runtime**.
* Your **Node.js program** (JavaScript on server) cannot run without the **Node runtime**.
* Even your **.NET applications** need the **.NET runtime**.

So runtime = **execution environment that acts like a translator**.

It takes your compiled or bytecode (`.class` in Java, `.pyc` in Python, IL code in .NET) and **translates it into instructions** your OS can actually understand. Without this translator, your OS will just stare blankly at the code.

### Now let’s talk about IDE…

One student asked me: *“Sir, then what is IDE?”*

Very good question. IDE stands for **Integrated Development Environment**.
Think of IDE like your **workshop**.

What do you get inside this workshop?

* A **text editor** (to write code)
* A **compiler / interpreter** (to translate code)
* A **debugger** (to catch mistakes)
* A **linker** and **loader** (to prepare executables)
* Extra helpers like profiler, memory explorer, logger, testing tools.

When all these are bundled into **one suit**, we call it an IDE.

Examples? Eclipse, Visual Studio, IntelliJ IDEA, PyCharm, Code::Blocks.
And of course, lighter editors like **VS Code, Sublime, Atom**—these are more like **smart text editors**, but when you add extensions, they can feel like mini-IDEs.

### Developer Environment vs Production Environment

Now here is a very important distinction.

* **Developer Environment** → This is where *you*, the developer, work.
  It has: IDE + Runtime + Libraries + Frameworks + Languages.
  You can build, test, and debug here.

* **Production Environment** → This is where your **actual users** run your application.
  There is no Eclipse, no Visual Studio, no PyCharm in production.
  What exists there?

  * Your **compiled code / executable image**
  * Required **libraries**
  * The chosen **framework**
  * The **runtime**
  * Plus, supporting tools like **databases** and **monitoring systems**

So in production, it’s not about *developing* anymore. It’s about *running reliably*.
Think of Amazon’s servers: your shopping cart, your payment gateway—they all run in **production environment** inside huge data centers. Developers don’t sit there with Eclipse open—they deploy the **final build** and let customers use it.

✅ So now you can clearly see the hierarchy:

* **Language** → Syntax
* **Libraries** → Ready-made functions
* **Frameworks** → Proven structure
* **Runtime** → Execution environment (translator)
* **IDE** → Workshop for developers
* **Developer Environment** → Where code is built
* **Production Environment** → Where code runs for users

👉 Shall I extend the story by showing you how **testing environment** and **staging environment** fit between development and production in the real industry pipeline?

Let me continue your mentor-style storytelling thread and tie it together 👇

So far, we clearly separated **developer environment** and **production environment**.
Now let’s bring in the **third important environment**: the **testing environment**.


👨‍🏫 *Imagine this like a movie production.*

* **Developer Environment** = rehearsal room 🎭
  Here actors (developers) practice their dialogues, try different expressions, sometimes make mistakes, sometimes restart again. They have mirrors, spotlights, and props (IDEs, debuggers, profilers, runtimes, libraries). Nobody from the outside world is allowed here — it’s messy but creative.

* **Testing Environment** = private screening room 🎬
  Once the rehearsal is done, before the movie is released to the public, a private screening is arranged. Only the director, producers, and critics (QA team, testers, automation tools) are invited. Their job? To check if the movie is good enough, spot mistakes, verify if the audience will like it, and ensure no big blunders remain. This is your **QA/testing server**.

  * It looks like the real theatre (replica of production environment).
  * It has the same screen, sound system, and seating arrangement (runtime, framework, databases, executables).
  * But it’s not for the public yet. It’s a safe place to fail, fix, and re-test.

* **Production Environment** = theatre premiere 🍿
  Now the movie is finally released to the audience (real end users). The public buys tickets, enters the theatre, and watches the polished movie.

  * This is where **Amazon.in**, **Flipkart.com**, or **IRCTC** websites run.
  * You never find developers sitting there with Visual Studio or Eclipse open.
  * Only the compiled, optimized, tested code runs with proper monitoring and firewalls.


📌 So in **software engineering**, we usually talk about three layers of environment:

1. **Developer Environment** – for building, debugging, experimenting.
2. **Testing (QA/Staging) Environment** – for validating correctness, performance, security.
3. **Production Environment** – for actual customers/end users.


⚡ Key point students must remember:
👉 *A good company never directly throws developer code into production.*
It always passes through **testing** before reaching the end user.
Otherwise, customers will become unwilling testers — and that’s the worst-case scenario for any product.

Would you like me to also extend this story by adding a **Staging/Pre-production environment** analogy (like a dress rehearsal just before premiere)? That’s often the last step companies use before going live.

👨‍🏫 *Let’s pause and reflect…*

We spoke about **developer environment**, **testing environment**, and **production environment**.
But here comes the twist 👉 all these environments can only play their role **if the foundation of the software itself is strong**.

Think of it like building a skyscraper 🏢.

* You may have fancy cranes (developer environment),
* you may have safety inspectors (testing environment),
* and you may have residents waiting to move in (production environment).

But if the **architect’s blueprint** is wrong — if the foundation design itself is weak — then no matter how hard the builders (developers) and inspectors (testers) work, the building will collapse.

That’s why before “writing a single line of code,” there is a critical phase: **requirements gathering, analysis, and design**.


🔑 **Developers build software binaries.**

* These binaries are generated through a **build process** (compilation, linking, packaging).
* They move from **developer environment → testing environment → production environment**.
* But remember: these binaries are only as good as the **design and requirements** behind them.

If the requirement itself is misunderstood, you are simply “building the wrong product faster.” 🚨

⚖️ **Roles in the IT world**

* A **developer** translates design into code, compiles it into binaries, and delivers features.
* A **tester** ensures those binaries behave correctly in the testing environment.
* But an **architect** ensures that what developers and testers are working on is **the right product, with the right design, and the right scalability**.

That’s why:

* Developer salary = X
* Architect salary ≈ 10X
  Because architects understand:
  ✔️ Software design principles
  ✔️ Design patterns
  ✔️ Architecture methodologies
  ✔️ SRS (Software Requirement Specification)
  ✔️ Business requirements

An architect bridges the gap between **customer expectations** and **developer execution**.

👨‍💻 Career growth story:

Many developers, after 6–8 years of experience, reach a crossroad:

* Either move towards **management** (becoming Project Manager 🧑‍💼)
* Or towards **technology leadership** (becoming Technical Architect 🏗️).

👉 Those who love team coordination, delivery timelines, and client handling often choose **Project Manager**.
👉 Those who love coding, design, deep problem-solving, and technology exploration often choose **Architect**.

Both are valuable. But the **architect’s role** ensures that every environment (developer, testing, production) has the right blueprint to work on.

🌍 Now coming to Siddharth’s doubt about **Linux flavors (Ubuntu, Debian, CentOS, RedHat)**:

Think of Linux like **different car models built on the same engine** 🚗.

* The **kernel** (engine) is the same.
* Different communities built different body styles (UI, package managers, utilities).
* Whether you drive a **Honda, Toyota, or Maruti** — the petrol (runtime libraries, syscalls) is the same.

So, when you deploy your application built on Ubuntu and move it to CentOS or Debian:

* The **core execution remains the same**.
* At most, you’ll see **minor performance or configuration differences**, but not a major impact.

That’s why large companies mix Linux flavors without fear. Some use CentOS for servers, some use Ubuntu, some use RedHat — but all run the same applications with minor tuning.

 Key takeaway for your students:
👉 **Good software isn’t about just writing code and pushing binaries.**
It’s about **understanding requirements → designing the right architecture → building → testing → deploying → maintaining**.
Each phase, each environment, and each role contributes — but the **architect** ensures the orchestra plays in harmony. 🎶
 

👨‍🏫 *“So friends, let me tell you one important thing before we move further…”*

Some of you are using **school Linux**, some of you prefer **Ubuntu**, some are more comfortable with **Red Hat** or **CentOS**. That’s fine.
Why? Because your **comfort level**, your **experience**, and your **existing command set** on that Linux flavor naturally influences your choice. If you know Ubuntu better, you’ll keep using Ubuntu. If your college lab had CentOS, you’ll be comfortable with CentOS.

And honestly — that’s okay ✅.

👉 But remember — **performance of an application is not just about the software**.
It also depends on the **hardware** of the system you are running on.

So, if tomorrow your software feels slow or lags on one machine, the solution isn’t always to “blame the software” or “change Linux flavor.” Sometimes, simply **upgrading RAM, CPU, or disk** solves the performance penalty. That’s why companies balance both:

* **Right software stack**
* **Right hardware capacity**


🎯 *Then I look at Siddharth and say:*
“See Siddharth, this is the practical answer — don’t get stuck on which Linux is the best. Think of hardware + software together.”

Now Akshay jumps in: *“Sir, which Linux flavor do companies mostly use?”*

👉 Good question. From my observation in corporates:

* **CentOS** and **Red Hat Enterprise Linux (RHEL)** are widely used in **enterprise production**.
* **Ubuntu** is popular for **learning, personal use, and prototyping** because it is free, user-friendly, and has strong community support.
* Enterprise Linux (RHEL/CentOS) often comes **console-only (no GUI)** — because real servers don’t need a graphical desktop. They need stability, security, and performance.
* And yes, Red Hat requires a **license**, which is why companies adopt it when they want vendor support and guaranteed enterprise features.

So remember this thumb rule:

* **Learn Ubuntu** → for practice, projects, and experimentation.
* **Know CentOS/Red Hat** → for real-world corporate deployment.

Even Microsoft, surprisingly, has its own Linux-based initiatives now. So it’s no longer “Windows vs Linux.” It’s about choosing the right Linux flavor for the right **context**.

🙌 *Then I clap my hands and say:*
“Okay, enough of which is good or bad Linux. We are not shopping on Amazon where you pick and choose brands. We are engineers. Our focus is: whatever the environment, whatever the OS — can we build the right software?”

So let’s come back to **our main journey of Software Engineering**.

📖 **Next phase: Requirement Gathering**

I ask you a question:
👉 When you write Java programs, what tool do you install? **Eclipse**.
👉 When you code in .NET, what do you need? **Visual Studio**.
👉 For Python? Maybe **Jupyter Notebook** or **Anaconda**.

But when you do **Requirement Gathering**, what is your tool?

Not Eclipse. Not Visual Studio. Not Jupyter.

Your best tools are:
🖊️ **Notebook and Pen**
📝 Maybe **Notepad** or **Paint** if you are documenting digitally.

Because requirement gathering isn’t about coding. It’s about **listening, observing, and capturing**.

🎭 *Now I role-play:*

Imagine Amazon calls our IT company and says:
“We want an **Online Shopping Solution**.”

Our first task is not to start coding. Our first task is:

* **Problem Definition** → What exactly is the problem?
* **Title** → Let’s call it “Online Shopping System.”

Now, what’s next?
We start asking Amazon:

* What do you want your customers to do?
* Should they be able to **browse a catalog**?
* Should they be able to **add products to a cart**?
* Should they be able to **place orders**?
* Should they be able to **cancel within 24 hours**?
* Should they get **recommendations, reviews, comments**?
* Should they be able to **track their order anytime**?
* Should **payment** be online, multiple gateways, COD?

Notice something?
👉 We are not **telling Amazon** what they need.
👉 We are **asking Amazon** what they want.

Requirement gathering = *listening exercise*, not *suggestion exercise*.

We might need **multiple meetings** with their business managers, domain experts, and stakeholders. Each meeting gives us more clarity. We capture all this into a structured document: the **Software Requirement Specification (SRS)**.

⚡ Key lesson for students:
👉 Requirement Gathering is the **foundation of Software Engineering**.
If you mess this up, no matter which Linux you use, no matter which tool you use, your software will fail.

 

👨‍🏫 *“So friends, now our job begins…”*

We discussed requirements, we captured them in our notebook. Now the time has come to **convert those requirements into a formal document**. And that document is called the **SRS – Software Requirement Specification**.

👉 Why SRS?
Because software development is like a relay race.

* The **Requirement Team** captures the requirements.
* They hand over the **SRS document** to the **Design Team**.
* The Design Team produces UML diagrams, DFDs, architecture… and hands them to the **Development Team**.
* Developers write **source code**, which goes to the **Build/Release Team**.
* The **Testing Team** then checks if the build is working.
* Finally, if testing passes, the **Deployment Team** moves it into production.

So you see, one document written carefully at the beginning becomes the **source of truth** for everyone in the cycle. If the SRS is wrong or incomplete → the entire software project collapses like a building built on weak foundation.


🎭 *Now I joke a little with students:*
“I can clearly see you all are very good online shoppers… because when I asked for requirements, within seconds you shouted: return and exchange, payment options, EMI, cash on delivery, discounts, refunds. That means your experience with Amazon and Flipkart is helping you here.”

That’s good ✅ — but now let’s behave like engineers, not customers. Customers **say what they want**, but engineers must **document it properly**.


📑 **So, let us learn the structure of an SRS document.**
Whenever you write an SRS, don’t think it is rocket science. Think of it like the project reports you submitted in college. You had a title page, certificate, index, then chapters. This is similar, but more structured.

An SRS usually contains:

1. **Purpose** – One short paragraph. Why are we writing this document? For example:
   *“The purpose of this SRS is to define the requirements for an Online Shopping Application that enables customers to browse, purchase, and track products.”*

2. **Scope** – Boundaries of the system. What this system will do, and what it will not do. Example:
   *“This software will handle product catalog, order management, and payments. It will not handle logistics delivery system directly; that will be managed by third-party APIs.”*

3. **Definitions / Acronyms** – Abbreviations explained. Example:

   * SRS = Software Requirement Specification
   * GUI = Graphical User Interface
   * COD = Cash on Delivery

4. **System Overview** – 2–3 lines describing the overall system.

5. **Functional Requirements** – The actual features.

   * Browse product catalog
   * Add to cart
   * Place order
   * Cancel within 24 hours
   * Payment options (COD, online, EMI)
   * Return & exchange facility

6. **Non-Functional Requirements** – Quality aspects.

   * Performance: System must support 1 million concurrent users.
   * Security: All transactions must use HTTPS and data encryption.
   * Availability: 99.9% uptime.
   * Usability: GUI must be simple and mobile-friendly.

7. **Constraints** – Technical or business limitations.

   * System should run on Linux servers with PostgreSQL database.
   * Must integrate with Razorpay and PayPal for payments.

8. **Hardware/Software Interfaces** – Example:

   * Web browsers (Chrome, Edge, Safari)
   * Mobile app (Android, iOS)
   * API integration with delivery system

9. **Optional Sections** – DFDs, Use Case Diagrams, or even a rough **schedule** if needed.


⚡ *Then I pause and challenge students:*
“Now tell me honestly — will you just copy-paste an SRS from Google? If yes, then I will say you are not ready for EDAC. Because SRS is not about Google search, it is about **your brain capturing requirements properly**.”

So I want each one of you to take **15 minutes** and **write your own SRS for Online Shopping Application**. It doesn’t matter if it is imperfect, it doesn’t matter if it is short — what matters is **you wrote it, you thought about it, and you structured it in the format I gave you**.

That’s how a real engineer practices.


🙌 *Final mentor note:*
“Remember, the SRS you write today may look like a small classroom exercise, but in the real world, companies spend weeks, even months, polishing this document. Because once the SRS is signed off by the client, it becomes a legal contract — the development team must build exactly what is written there. No less, no more.”

👨‍🏫 *Mentor mode ON*

“Listen carefully… if someone thinks, *‘Arre SRS toh Google se copy kar lunga, dusre ka document download karke bhej dunga’*, then let me warn you straight:

👉 You may get a job like that.
👉 You may even get a ₹60,000 salary offer.
But within **one month**, the company will find out.
Because in the real world, every day your manager will ask you to **capture requirements, analyze, and write documentation**. If you only know how to copy-paste from Google, you won’t survive.

And remember — I have been working honestly in this field for more than 23 years. With full passion, full sincerity. If a person like me curses you for dishonesty, that curse will be a *real curse*. And trust me, that will hurt your career more than you imagine.

That is why I am requesting you all with folded hands 🙏 — don’t cheat yourself.
Today you have a golden chance to *practice honestly*.


So here’s what we’ll do:

☕ Take a **10-minute tea break**.

* Some of you may have chai, some may have juice, some nimboo pani.
* Refresh your mind.

⏰ At **3:35 sharp** we will come back.
Then I want **each and every one of you** to open Notepad and write your own **SRS for Online Shopping Application**.

📄 Your document should have at least these sections:

1. **Purpose**
2. **Scope**
3. **Definitions / Acronyms**
4. **Functional Requirements**
5. **Non-Functional Requirements**
6. **Constraints**

That’s it. Even if it’s not perfect, it should be *yours*.


📲 Once done, you will send me your text file on WhatsApp with your **PRN number + Name**.
There are 233 of you here. That means I want to see **233 WhatsApp messages** with attached text files.

Don’t worry about mistakes. Mistakes are proof you tried.
But if you submit a Google copy-paste, then remember my curse 😠 — you won’t get a job, or even if you get, you won’t last.


🌟 So, enjoy your tea, refresh yourself, and at 3:35 we will start this important exercise.
Because this SRS you are going to write is the **first real engineering task of your career**.”

 

👨‍🏫 *Mentor Storytelling Mode*

“Listen carefully… at this point, many of you are thinking — *‘Arre Sir, coding toh ho jayega, but this document likhna bada boring aur mushkil hai.’*
Exactly! That is why I am insisting.

👉 Writing **code** is like cooking in your own kitchen. You know the recipe, you put ingredients, you serve the dish.
👉 Writing an **SRS document** is like writing the recipe book itself. That recipe book is not only for you — it is for the next chef, the next customer, the next investor.

So today’s task is not about showing me some copy-paste file.
No Google, no ChatGPT, no shortcuts.
I want to see **your own handwriting, your own thought process**.


🔹 Step 1: First, type your SRS in **Notepad**.
Why? Because while typing, you can edit easily — delete, rewrite, refine.
Writing directly on paper will make you scratch, erase, rewrite, and waste time.

🔹 Step 2: Once you finalize the draft, take your pen and notebook, and **write it neatly on paper**.
This will discipline your thinking.
Because when you write with your own hand, you give commitment to your idea.

🔹 Step 3: Take a **clear photo** of that handwritten document and send it to me on WhatsApp with your **PRN + Full Name**.
That photo is your attendance. No photo = Absent.

Now let me warn you again 🚨 — this SRS will not stay only between you and me.
Your documents will be shown on screen, your names will be visible, and all 230+ students will see it.
We will discuss, analyze, and I will suggest improvements.
So write it properly, as if you are submitting to a client.


Now Ankita just asked, *‘Sir, what is Functional Requirement and Non-Functional Requirement?’*
Good question! But I won’t give you the full answer right now.
Because if I spoon-feed you, you won’t think.

👉 So for now, you write what **you understand** by functional and non-functional.
Maybe you’re wrong, maybe you’re half correct — no problem.
At least your brain will attempt.
Then I will explain the professional definition and you will remember it forever.


So students, don’t take this lightly.
Coding is a challenge, yes. But documentation is a *bigger challenge*.
Because if you fail in writing requirements, your code will collapse later.

This SRS you are writing today is not a homework.
It is your **first professional contract document**.
Do it honestly, do it neatly, and remember — your marks and your future discipline both depend on it.”
